/* This file is part of VoltDB.
 * Copyright (C) 2021 VoltDB Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

package voltdb.tasks;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.voltdb.VoltTable;
import org.voltdb.client.ClientResponse;
import org.voltdb.task.Action;
import org.voltdb.task.ActionGenerator;
import org.voltdb.task.ActionResult;
import org.voltdb.task.TaskHelper;
import org.voltdb.utils.CompoundErrors;

/**
 * Task for polling the COMMANDLOG statistics and reporting when the command log is growing unexpectedly.
 * <p>
 * Command log segments are created on an as-needed basis to store all transactions that are not
 * in the last truncation snapshot. A truncation snapshot is triggered when half the available segments
 * have been consumed. If snapshots typically take longer and the transaction volume is high the segment
 * pool will stabilize at a higher number of segments than if snapshots finish quickly or the transaction
 * volume is low. As such, it is recommended that this task not be deployed in production environments
 * until the peak workloads are well understood. Specifically, after the cluster has stabilized, the
 * number of segments allocated can be identified using the SEGMENT_COUNT column of the @Statistics
 * COMMANDLOG system procedure. If the segment count grows significantly beyond this peak, it suggests
 * that the snapshot subsystem has stopped working and that the system needs to be restarted as soon
 * as possible.
 * <p>
 * Note that the longer the system stays up, the larger the command log that will need to be
 * replayed during Recovery and the longer the Recovery process will take. Therefore, it is important to
 * determine if snapshots are indeed hung using the @Statistics SNAPSHOTSTATUS as soon as the warnings
 * generated by this task start appearing in the log
 * <p>
 * Example task creation:<br>
 *
 * <pre>
 * CREATE TASK commandlogMon ON SCHEDULE EVERY 5 MINUTES
 *     PROCEDURE FROM CLASS voltdb.tasks.GrowingCommandlog WITH (20)
 *     ON ERROR LOG;
 * </pre>
 * <p>
 * Parameters which need to be provided when the task is defined
 * <table>
 * <tr>
 * <th>Parameter</th>
 * <th>Description</th>
 * </tr>
 * <tr>
 * <td>Warning in-use segment count</td>
 * <td>When the IN_USE_SEGMENT_COUNT in the COMMANDLOG statistics reaches this threshold warnings will
 * be logged until the value drops back down. This value should be set to a number greater than the
 * SEGMENT_COUNT observed after some period of normal operations. SEGMENT_COUNT represents the highest
 * IN_USE_SEGMENT_COUNT ever needed by the system</td>
 * </table>
 */
public class GrowingCommandlog implements ActionGenerator {
    // Messages visible for test validation
    final static String MSG_ERROR_BAD_SEGMENT_CNT = "Error max in-use segment count <= 0.";

    private TaskHelper m_helper;
    private int m_maxSegmentCount;
    private int m_statsCallFailureCount = 0;
    private static final int MAX_BACK_TO_BACK_STATS_FAILURES = 4; // This could be parameterized

    public static String validateParameters(TaskHelper helper, int maxSegmentCount) {
        CompoundErrors errors = new CompoundErrors();
        if (maxSegmentCount <= 0) {
            errors.addErrorMessage(MSG_ERROR_BAD_SEGMENT_CNT);
        }
        // Add more errors or warnings if there are more parameters. Other possible parameters
        // could be how old the last truncation snapshot is allowed to be or how many times
        // the warning will be promoted to an error or even a call to @Shutdown
        return errors.getErrorMessage();
    }

    public void initialize(TaskHelper helper, int maxSegmentCount) {
        this.m_helper = helper;
        this.m_maxSegmentCount = maxSegmentCount <= 0 ? Integer.MAX_VALUE : maxSegmentCount;
    }

    @Override
    public Action getFirstAction() {
        return Action.procedureCall(this::handleStatisticsResult, "@Statistics", "COMMANDLOG", 0);
    }

    @Override
    public boolean isReadOnly() {
        return true;
    }

    @Override
    public Collection<String> getDependencies() {
        // This class has no external dependencies outside of java standard library and voltdb
        return Collections.emptyList();
    }

    /**
     * Callback to handle the result of the statistics query and return the next statistics call
     *
     * @param result of statistics query
     * @return next statistics action
     */
    private Action handleStatisticsResult(ActionResult result) {
        ClientResponse response = result.getResponse();
        ProblemMsg msg = null;

        if (response.getStatus() == ClientResponse.SUCCESS) {
            m_statsCallFailureCount = 0;
            VoltTable stats = response.getResults()[0];

            while (stats.advanceRow()) {
                int currSegmentCnt = (int)stats.getLong("IN_USE_SEGMENT_COUNT");
                if (currSegmentCnt > m_maxSegmentCount) {
                    if (msg == null) {
                        msg = new ProblemMsg();
                    }
                    String hostname = stats.getString("HOSTNAME");
                    msg.udpate(currSegmentCnt, hostname);
                }
            }
            if (msg != null) {
                m_helper.logWarning(msg.buildWarningString() + " The expected maximum is " + m_maxSegmentCount +
                        " segments. This is an indication that Truncation Snapshots are no longer completing" +
                        " either because there is a problem in the snapshot subsystem or because other types" +
                        " of snapshots are in progress. Large CommandLogs will slow down a cluster recovery. If" +
                        " truncation snapshots are no longer completing, it is recommended that the cluster be" +
                        " shutdown and recovered as soon as possible.");
            }
        }
        else {
            m_statsCallFailureCount++;
            if (m_statsCallFailureCount >= MAX_BACK_TO_BACK_STATS_FAILURES) {
                m_statsCallFailureCount = 0;
                m_helper.logError("The CommandLog Monitor Task (" + m_helper.getTaskName() + ") is not" +
                        " operational because the statistics subsystem is not reporting COMMANDLOG status.");
            }
        }

        return Action.procedureCall(this::handleStatisticsResult, "@Statistics", "COMMANDLOG", 0);
    }

    /**
     * Simple class to hold the information which should be reported
     */
    protected static final class ProblemMsg {
        List<String> hostNames = new ArrayList<>();
        int minSegments = Integer.MAX_VALUE;
        int maxSegments = 0;

        ProblemMsg() {
        }

        /**
         * Update this message instance with information the hosts with large segment pools
         *
         * @param inUseSegments Number of segments this host has filled up
         * @param hostName Name of host that has consumed too many segment
         */
        void udpate(int inUseSegments, String hostName) {
            minSegments = Integer.min(minSegments, inUseSegments);
            maxSegments = Integer.max(maxSegments, inUseSegments);
            hostNames.add(hostName);
        }

        String buildWarningString() {
            if (minSegments == maxSegments) {
                return "Hosts " + String.join(", ", hostNames) + " have consumed " +
                        maxSegments + " CommandLog segments";
            }
            else {
                return "Hosts " + String.join(", ", hostNames) + " have consumed between " +
                        minSegments + " and " + maxSegments + " CommandLog segments.";
            }
        }
    }
}
